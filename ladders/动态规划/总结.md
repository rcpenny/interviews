## DP三大类型
- 计数（有多少方式） 求最大最小值  求存在性

## DP解决问题的基本流程
0. 最后一步，子问题
1. 确定状态
2. 转移方程
3. 初态边界  
4. 顺序计算

## DP时间复杂度
通常来说, 动态规划的时间复杂度 = 状态数 * 状态转移代价

## 常见DP类型  (时间空间优化)
- 坐标型（20%）序列型（20%）划分型（20%）区间型（15%）
- 背包型（10%）最长序列型（5%）博弈型（5%）综合型（5%）

## 坐标型DP小结 (DP on coordinates)
给定一个序列或网格 需找到序列中（某些个子序列），网格中的某条路径 的 某种性质最大/最小  计数  存在性
f[i]的下标i表示以a[i]为结尾的子序列性质
同理 f[i][j]以左边(i,j)表示以grid[i][j]为结尾的网格性质

follow up:滚动数组优化空间

## 序列型DP小结 （DP on Sequence）
- 序列型DP： 前i个...最小/方式数/可行性
- 给定一个序列, DP方程f[i]下标i代表前i个元素a[0],a[1],...,a[i-1]的某种性质
1. 当思考DP最后一步时，这一步的选择依赖前一步的某种状态
2. 初始化时，f[0]代表前0个元素/前0天的情况
3. 计算时，f[i]代表前i个元素(0 ~ i-1)的某种性质

## 划分型DP小结
- 给定长度为N的序列或字符串，要求划分车成若干份（段数不限，或k段，每段满足一定的性质)
- 做法：类系序列型，通常加上段数信息. 
  1. (最优策略 最后一步 -> 最后一段 如何划分出来 某个j -> n-1) 枚举最后一段的起点
  2. 如果段数不限，用f[i]表示前i个元素分段后的最值，可行性，方式数
  3. 如果指定段数，用f[i][j]表示前i个元素分j段后，的最值，可行性，方式数

## 博弈型DP小结
- 思考时不要有后手的思想，每次move后，当前出招的人就是先手.
- 博弈动态规划通常从第一步分析，因为局面越变越简单
- 怎么选让自己赢的一步，走了这一步对面剩下的局面必输（必胜）

## 背包DP小结
- 两个关键点：还有几个物品，还剩多少承重
- 背包问题中，至少有一维和总承重有关
- 最后一步：
  1. 最后一个背包内的物品是哪个
  2. 最后一个物品有没有进背包
- 数组大小和最大承重target有关

## 区间型DP小结
- 状态自然定义为f[i][j] 表示面对子序列[i,...,j]的最优性质

## 记忆化搜索