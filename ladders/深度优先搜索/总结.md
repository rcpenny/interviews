## 隐式图深度优先搜索
在非二叉树上的深度优先搜索（Depth-first Search）中，
90%的问题，不是求组合（Combination）就是求排列（Permutation）。
特别是组合类的深度优先搜索的问题特别的多。
而排列组合类的搜索问题，本质上是一个“隐式图”的搜索问题。
\
碰到让你找所有方案的题，基本可以确定是 DFS\
除了二叉树以外的 90% DFS的题，要么是排列，要么是组合\


找所有满足某个条件的方案 找到图中的所有满足条件的路径\
路径 = 方案 = 图中节点的排列组合\
很多题不像二叉树那样直接给你一个图（二叉树也是一个图）\
点、边、路径是需要你自己去分析的\

## Deep copy
```java
results.add(new ArrayList<Integer>(subset));
```
事实上，这句话是调用了 ArrayList 的一个构造函数（Constructor），这个构造函数可以接受另外一个 ArrayList 作为其初始化的状态。
这种方式，我们叫它深度拷贝（Deep Copy）

## 递归三要素
• 递归的定义
• 递归的拆解
• 递归的出口

## 排列组合问题 Combination & Permutation
组合问题\
问题模型：求出所有满足条件的“组合”。\
判断条件：组合中的元素是顺序无关的。\
时间复杂度：与 2^n 相关。（要或不要）\
\
排列问题\
问题模型：求出所有满足条件的“排列”。\
判断条件：组合中的元素是顺序“相关”的。\
时间复杂度：与 n! 相关。（这个位置有几种选法）\

## 搜索，动态规划，二叉树的时间复杂度计算通用公式
搜索的时间复杂度：O(答案总数 * 构造每个答案的时间)\
举例：Subsets问题，求所有的子集。子集个数一共 2^n，每个集合的平均长度是 O(n) 的，所以时间复杂度为 O(n * 2^n)，\
同理 Permutations 问题的时间复杂度为：O(n * n!)\
\
动态规划的时间复杂度：O(状态总数 * 计算每个状态的时间复杂度)\
举例：triangle，数字三角形的最短路径，状态总数约 O(n^2) 个，计算每个状态的时间复杂度为 O(1)——就是求一下 min。所以总的时间复杂度为 O(n^2)\
\
用分治法解决二叉树问题的时间复杂度：O(二叉树节点个数 * 每个节点的计算时间)\
举例：二叉树最大深度。二叉树节点个数为 N，每个节点上的计算时间为 O(1)。总的时间复杂度为 O(N)\