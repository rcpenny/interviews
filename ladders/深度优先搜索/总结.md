## 隐式图深度优先搜索
在非二叉树上的深度优先搜索（Depth-first Search）中，
90%的问题，不是求组合（Combination）就是求排列（Permutation）
而排列组合类的搜索问题，本质上是一个“隐式图”的搜索问题。

碰到让你找所有方案的题，基本可以确定是 DFS
除了二叉树以外的 90% DFS的题，要么是排列，要么是组合

找所有满足某个条件的方案 找到图中的所有满足条件的路径
路径 = 方案 = 图中节点的排列组合
很多题不像二叉树那样直接给你一个图（二叉树也是一个图）

## Deep copy
```java
results.add(new ArrayList<Integer>(subset));
```

## 递归三要素
• 递归的定义
  ```java
  // 常有的几个参数 
  // 以k sum 2 为例
    void dfs(int[] nums,          // 元数据
             int index,           // 对元数据的控制
             int target,          // 目标状态 optional
             int limit,           // 限制条件 optional
             String list,         // 当前dfs位置的状态
             List<String> res);   // 最终结果 optional
  ```
• 递归的拆解
  ```python
  # 进入下个递归前的条件：去重？去掉特殊条件？能不能进入？
  # 更新状态，递归，回溯状态
  ```
• 递归的出口
  ```java
  // 观察递归定义中的一些params 类似...
  // index, target, k 到达或越界
  // dfs当前位置的状态为理想状态
  // results加入时记得是否需要deep copy
  ```

## 排列组合问题 Combination & Permutation
- 组合问题
1. 问题模型：求出所有满足条件的“组合”
2. 判断条件：组合中的元素是顺序无关的
3. 时间复杂度：与 2^n 相关

- 排列问题
1. 问题模型：求出所有满足条件的“排列”
2. 判断条件：组合中的元素是顺序“相关”的
3. 时间复杂度：与 n! 相关

## 搜索，动态规划，二叉树的时间复杂度计算通用公式
搜索的时间复杂度：O(答案总数 * 构造每个答案的时间)\
举例：Subsets问题，求所有的子集。子集个数一共 2^n，每个集合的平均长度是 O(n) 的，所以时间复杂度为 O(n * 2^n)，\
同理 Permutations 问题的时间复杂度为：O(n * n!)

用分治法解决二叉树问题的时间复杂度：O(二叉树节点个数 * 每个节点的计算时间)\
举例：二叉树最大深度。二叉树节点个数为 N，每个节点上的计算时间为 O(1)。总的时间复杂度为 O(N)