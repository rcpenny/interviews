## 宽搜要点 BFS Key Points
使用队列作为主要的数据结构 Queue\
是否需要实现分层？\
需要分层的算法比不需要分层的算法多一个循环\
Java   size=queue.size()

## BFS in Graph
图中存在环\
存在环意味着，同一个节点可能重复进入队列 Set<E> visisted\
时间复杂度\
O(N + M) 其中 N 为点数，M 为边数

## BFS in Matrix
R行C列\
R*C个点，R*C*2 条边（每个点上下左右4条边，每条边被2个点共享）。\
矩阵中BFS时间复杂度 = O(R * C)\
其余一些matrix问题可用并查集 Union Find解决

## 拓扑排序概念
入度（In-degree）：\
有向图（Directed Graph）中指向当前节点的点的个数（或指向当前节点的边的条数）

### 算法描述：
0. 生成数据结构（如果需要的话）
1. 统计每个点的入度
2. 将每个入度为 0 的点放入队列（Queue）中作为起始节点
3. 不断从队列中拿出一个点，去掉这个点的所有连边（指向其他点的边），其他点的相应的入度 - 1
4. 一旦发现新的入度为 0 的点，丢回队列中

拓扑排序并不是传统的排序算法\
一个图可能存在多个拓扑序（Topological Order），也可能不存在任何拓扑序

## 拓扑排序的四种不同问法
求任意1个拓扑序（Topological Order）\
问是否存在拓扑序（是否可以被拓扑排序）\
求所有的拓扑序 DFS\
求是否存在且仅存在一个拓扑序 Queue中最多同时只有1个节点\

考点1：如何构建图\
考点2：如何存储图\
 HashMap<key, value> pre_course -> after_course 想清楚拓扑排序的箭头方向，左边key，右边value\
考点3：如何拓扑排序

## 总结 Conclusion
能用 BFS 的一定不要用 DFS \
• BFS 的两个使用条件\
• 图的遍历（由点及面，层级遍历）\
• 简单图最短路径\
• 是否需要层级遍历\
• size = queue.size()\
• 拓扑排序必须掌握\
• 坐标变换数组\
• deltaX, deltaY\
• inBound\
