https://drive.google.com/file/d/1J07FKBmkLgfGQNeSx34C09QE4aHa5Jtf/view

1. 把matrix的数按frequency排序后zigzag插回进去
2. arrayQuery

bank transfer
http://web.mit.edu/6.005/www/fa15/classes/23-locks/#locking
1. 一段从账户取钱存到另一个账户的代码。
2. 问有什么问题。答：需要用transaction来解，细聊了一下transaction是怎么保证正确性的，transaction提交过程中发生的事。
第二题是转账的，账户A减少，账户B增加，要用transaction
第二题就是经典的DB transaction那题
def bad_transfer(src_account, dst_account, amount): 
    src_cash = src_account.cash # DB read
    dst_cash = dst_account.cash # DB read
    if src_cash < amount: 
        raise InsufficientFunds
    src_account.cash = src_cash - amount # DB write
    src_account.send_src_transfer_email()
    dst_account.cash = dst_cash + amount # DB write     
 
    dst_account.send_dst_transfer_email()

反正就是扯了一堆有的没‍‍‍‌‍‍‍‍‍‌‍‍‌‍‌‍‌‍‍的
为啥会有问题（口语捉急，解释了挺久的）最后写了一下代码举了例子。总体就是，在db read和db write之间，src_cash - amount可能就不再是src的值了，因为发生了别的tranfer，所以这两个read和write要锁在一起 （地里有些帖子的答案是错的 ）
 2. 问锁是application level的还是db level，顺便让我说一下db level的锁能够做啥。
 3. 问锁的是整个函数，还是单个变量。锁的是单个变量，如果锁了函数，那么就变成整个system串行了。
 4. 因为邮件的缘故，我提到了rollback，他就让我说一下为啥会rollback，然后假设这个函数包含一个transaction（或者一个transaction包含这函数），那么transaction的开始和结束再哪。
嗯。。这方面我就不太懂，我觉得写的时候应该是读不了的吧。除非写不是原子操作。
如果写不是原子操作 ...
对啊，写的时候加写锁，读的时候加读锁，这个没有什么可以疑问的啊？
我的意思是，读的时候一定要加锁，不然，你在读的同时，一个写锁上来，你读的数据就是一半是以前的，一半是之后的
LZ 第二题提到commit model就应该ok了
第二题的email在给sender发之前是不是应该先把receiver的钱弄好啊，万一发了之后crash，s‍‍‍‌‍‍‍‍‍‌‍‍‌‍‌‍‌‍‍ender发现自己钱被扣了但是receiver发现自己还没收到，虽说在系统和数据层面上没有影响，但是可能会影响到用户体验哈哈

给一段伪代码，‍‍‍‌‍‍‍‍‍‌‍‍‌‍‌‍‌‍‍从中找出可能的问题
伪代码做的事情是从srcAccount给dstAccount转账amount，大概是
function accountTransfer(srcAccount, dstAccount, amount)
  srcBalance = db.getBalance(srcAccount)
  if srcBalance >= amount:
    dstBalance = db.getBalance(dstAccount)
    db.setBalance(srcBalance - amount)
    sendEmailTo(srcAccount)
    db.setBalance(dstBalance + amount)
    sendEmailTo(dstAccount)

看看其他的robinhood面经 一模一样 注意的是 transaction那题 请务必搞明白多线程锁的实现 read write lock的code模版 写得要信手捏来 说得得有理有据 如果用数据库实现的话 就不需要自己来实现lock了 但是对于自己实现的话 样例代码就足够了 但要写得有理有据
其实我不知道。。。我就是说的database的transaction可以用来lock全局object感觉他还比较满意 不是很知道nosql


1. Design a Messaging App for Family,
- UI/UX, features
- How to store data
- Design APIs
- Android Architecture and Implementation
2. Implement an Android with an infinite list, each item has a counter and a button, it starts counting as long as the row is visible on screen. The button shows pause/play, tap on that will pause/continue the timer for that specific row.

4. Implement a Publisher Subscriber
public void publish(Stock stock)
public interface Subscription {
  void unsubscribe();
}
public interface Callback {
  void onDataChanged(Stock stock);
}
public Subscription subscribe(String symbol, Callback callback)
Follow up, implement subscribe by tags, get notified when stock tags changed
public interface CallbackByTag {
  void onDataChanged(Set<Stock> stocks);
}


onsite
10am 到下午 3pm，总共4轮。
第一轮：跟经理‍‍‍‌‍‍‍‍‍‌‍‍‌‍‌‍‌‍‍聊聊经验，没有coding
第二轮：跟一位前端工程师做题。内容是用create-react-app的模版来写一个模拟苹果spotlight search的react component。（感觉这一轮是我挂的主要原因，要很快的用电脑写出这个component，然后css比较像，还有autocomplete的功能（用一个已有的object里的字去autocomplete）。我写到最后autocomplete有点问题时间不够了。）
第三轮：leetcode 140 word break II但是只要return一个解法就好了
第四轮：聊关于怎么architect一个real-time messaging application，比如messenger

电面就一轮，面试官是我后来onsite的面试官。题目就是地里常见的面经，旋转打印矩阵，加上一个security方面的问题。楼主并没有被问到地里常见的那个多‍‍‍‌‍‍‍‍‍‌‍‍‌‍‌‍‌‍‍线程的问题，而是被问到了一个很类似PKI design的问题，感觉这里也是因为投的职位的原因，可能不那么具有参考性。
然后是onsite，四轮，一个下午就面完了。
第一轮的名字叫日志分析，给的一个json的input，每一行表示一些user登陆server的信息，要求处理json的数据，然后再设计一些security方面的分析，找出malicious user。这个是在coderpad上进行的，所以按理来说应该是要run出结果的。但是楼主用的是Java，一时半会实在不好处理json的数据，所以这一面并没有真正run出结果。根据后面recruiter的反馈，应该是fail在这里了，所以有相似的同学可以换成python。
第二轮叫scalable system，记忆已经比较模糊了，但是就是一个非常常见的分布式里的partition，replication之类的设计。
第三轮是coding，计算器，有括号，加和乘，但是有一个什么限制条件一下就把这题给变成了简单题，非常简单。最后要设计test case跑test。
第四轮architecture，主要就是讨论，一个API service的load banlancer后面会有很多个server，每个server都会有一个log，如何将这些log merge起来，并且设置monitor，alert之类的。楼主的答案是基于Kafka的。


1. swap characters in pair
Given a string, you need to swap characters in pairs. s[0] is‍‍‍‌‍‍‍‍‍‌‍‍‌‍‌‍‌‍‍ swapped with s[1], s[2] is swapped with s[3]... if the string has odd number length, the last character will not be swapped.
2. broken keyboard
Given a string and an array of character, the string represents the words you need to type, each word is separated with a space character and there is no leading or trailing space. The array of character contains only lowercase letters, representing the characters you can type on the broken keyboard(Note: you can also type uppercase version of these letters). Besides these letters, you can also type any digit or special characters. Now, determine how many words in the given string you can type using the broken keyboard.
3. determine if strings are close
Write a function to determine if two strings are close. For two strings to be considered close, they must be same after doing the either or both of following steps for any number of times: 1) swap any two characters within one string 2) change all occurrences of one character in one string into another character that exists in the same string e.g. "aaaabb" can be converted into "bbbbaa"
4. process queries
Given an integer array (int[] a) and a 2D array(int[][] queries). The 2D array represents a set of queries. You need to process the queries to find the number of occurrence of a specific number in array a between index i and j(inclusive). Each query is formatted in the following way: Each query has size 3(query.length=3, 0<=i<queries.length) The first element is the lower index i. The second element is the higher index j and the third element is the number you are searching for. Return the sum of numbers of occurrences you get from processing all the queries. (Brute force solution will not be efficient enough to pass all test cases)


* Order Book
Take in ‍‍‍‌‍‍‍‍‍‌‍‍‌‍‌‍‌‍‍a stream of orders (as lists of limit price, quantity, and side, like ["155", "3", "buy"]) and return the total number of executed shares.

Rules
- An incoming buy is compatible with a standing sell if the buy's price is >= the sell's price. Similarly, an incoming sell is compatible with a standing buy if the sell's price <= the buy's price.
- An incoming order will execute as many shares as possible against the best compatible order, if there is one (by "best" we mean most favorable to the incoming order).
- Any remaining shares will continue executing against the best compatible order, if there is one. If there are shares of the incoming order remaining and no compatible standing orders, the incoming order becomes a standing order.

Example input (more details are in the slide deck):
Stream of orders
("150", "10", "buy"), ("165", "7", "sell"), ("168", "3", "buy"), ("155", "5", "sell"), ("166", "8", "buy")

Example output:
11

输入为两个String S 和 T，只含有lowercase和数字，要求只能从任一String中去掉一个character，使得‍‍‍‌‍‍‍‍‍‌‍‍‌‍‌‍‌‍‍S lexicographcally smaller than T，求有多少种方法。

第四道题：
有一个二维board，每个位置上对应的数值为(i+1) * (j+1)， i和j分别为横纵坐标。
输入是int n, int m, int[][] queries，n和m代表这个board有n行m列，queries里面为对board的操作
有三种操作：[0]代表求当前board中最小的数，[1, x] 代表将第x行deactivate，[2,y] 代表将第y列deactivate。最后输出为经过这个queries后所有输出的值的list。
比如int[][] queries = {{0}, {1,2},{2,3}, {0}}就代表先把当前board最小值放入结果的list，再把第2行deactivate，再把第3列deactivate，再将当前最小值加入结果


(2) list of int, return the most frequent digit:
eg:
input: [ 10, 20, 30, 33 ]
output: [ 0, 3]
因为 数字0出现三次，3 出现三次，他们是出现次数最频繁的

（3） sort the number in diagonal of matrixeg:
10   9  12              3   4  12
16  18  20     ->    2   8    9
1     2    3              1   7   10

(4) DP:类似于 Maximum Product Cutting 这个问题，input：(arr, n) 给一个list，其中包含每个rope的长度，n表示想要从这些绳子中截出的子绳子的数量，求每段绳子的最长长度。


onsite
1. reverse digit: 给一个int型数字n， 从左到右将相邻两位的数字交换，例如 12345 -> 21435, 如果最后只剩一位则不交换。题目给定n为正数， 第二位不会‍‍‍‌‍‍‍‍‍‌‍‍‌‍‌‍‌‍‍是0， 并且不会出现溢出的情况，比较容易。
2. sumOfString: 给两个数字型String， 从右到左将每一位相加后得到的数字concatenate起来，例如11 + 9 -> 110 （1+9 = 10, 剩下一位1 和10 合并得到110）
3. rotateMatrix: 给一个正方形的matrix，在不改变两条对角线的数据的情况下，将matrix 旋转 90， 180， 270， 360度
4. matrixQueries: 给一个n * m的matrix m，index 从 1算起，m(i, j) = i + j （或者是i * j有些记不清了）, 初始matrix中所有元素都是active的，再给二维数组 int queries[num][2]，queries代表一个操作命令，操作规则如下：
queries[0] == 0: 向输出数组中添加当前矩阵中所有active的元素的最小值
queries[0] == 1: 将行数为queries[1]的元素deactive
queries[0] == 2: 将列数为queries[1]的元素deactive
将num个query操作完成后，最后返回long[]型数组


onsite
总共4论， 每轮45 分钟， 分别是 behavior question, system design, codi‍‍‍‌‍‍‍‍‍‌‍‍‌‍‌‍‌‍‍ng (code quality), algorithm. coding第一轮是一个很简单的题， 要上ide 写， 主要考察code quality. 第二轮 coding 是算法，不用写代码， 基本上他出一个题我说思路， 总共面了三个题， 都挺简单的。求米求米
1.‍‍‍‌‍‍‍‍‍‌‍‍‌‍‌‍‌‍‍ 比赛配对，最远的两个配对，given even int n, output a string. ex 4 -> ((1, 4), (2,3))
2. sum of string
3. given an array, split it into two subarrays which don't contain any duplicate element and have same size
4. 忘了。。
限时1h10min，可以半小时解决
4. 面经里见‍‍‍‌‍‍‍‍‍‌‍‍‌‍‌‍‌‍‍过，给一个array，[1,3,2,3......8],还有一个query array[[1, 3, x]...] 代表从index 1 到 index 3 ，这个数字x 出现了多少次。题目有坑，用array解，别用treeset，有三个case过不去，最后几分钟才灵机一动改array了



发个小众的Robinhood onsite
1. 和一个founding eng聊‍‍‍‌‍‍‍‍‍‌‍‍‌‍‌‍‌‍‍项目
2. 给一个数组，找这个数组的某个区间使得区间的中位数最大，我也没想很清楚就不贴答案了
3. coding 写一个function来算input的mean max min等等，着重考察coding style。上了个厕所结果这轮没写完
4. system design，假设exchange有一个异步的API来post market order和查询order状态 要求做一个robinhood的交易功能，要求任何情况都不能挂。这轮被考到了，需要考虑exchange的API timeout和server crash的情况。面试官让你写实现功能的flow然后考虑哪一步会挂。主要是local db会有一个state，exchange那边会有一个state，在上述情况有可能out of sync。思路是先commit local db的transaction再去call exchange API，然后用aync job来verify和fix inconsitency

1. 代码题 leetcode LRU cache，  
2. robinhood有一个股票价格变动幅度5%就发一个push notification给关注这个股票的用户， 要求设计一个系统完成这个功‍‍‍‌‍‍‍‍‍‌‍‍‌‍‌‍‌‍‍能
hr反馈挂在系统设计上



好公司 在menlo park 很小 300-400人 建筑风格有点老北京饭店古堡的感觉 去onsite才明白为什么叫robinhood 公司的目‍‍‍‌‍‍‍‍‍‌‍‍‌‍‌‍‌‍‍标是什么
【onsite】
在一个碉堡样子的房子里面 门卫大冬天站在外面给人开门 4轮面试 早上一轮 下午三轮 第一轮是manager 问背景 后两轮就是专业知识加上coding 最后一轮是一个小project
总体来说对投的组的专业要求比较高 如果做过所投职位高度相关的project 一定要对每一个细节都很清楚 即使不是你做的部分 算法题不难 easy或者medium水平 利口calculator这个水平
专业技术要扎实 比如public key infrastructure里面的certificate 都有哪些fields 这些fields楼主还是功底比较扎实的 能说得很清楚 但是certificate有三个版本 支持option fields，被问到option fields还有如何试用option fields来解决一个实际问题 以及好一些在RFC里面的内容 如果没有专门做过相关的project还是比较不容易知道的知识


第一轮 写一个Android App，加载一个列表，每一行有一个timer count时间
第二轮 system design。设计一个message app for families。需要考虑产品功能，UI设计，API设计以及后台的Data Model
第三轮 白板 word breakII 简化版，只用打印出一个valid的结果就行
第四轮 implement Publisher Subscriber

‍‍‍‌‍‍‍‍‍‌‍‍‌‍‌‍‌‍‍onsite四轮
- hiring manager聊项目，需要你介绍项目背景的具体过程，会问一些问题
- 算法题。给问题，讲解体思路和分析时间空间复杂度，不需要写具体code。
- coding。电脑上写code，可以用ide。题目就是简单的模拟题。要求是写出可以提交到prod的代码，看你编程习惯，unit test之类的吧
- 系统设计。设计一个他们相关的系统。这轮答的不好。牵涉到transaction，预期是用database里的transaction的支持（他们用Postgres）。我没往这上面靠，自己加了一堆锁试图解决问题，但自己实现transaction太难了。



Our interview focuses on general problem-solving skills, algorithmic thinking, and CS
fundamentals. During the live-coding exercise, we’ll ask you to solve 1-2 problems and write
clean, functional code to implement a solution.
Be sure to have a computer with a reliable internet connection for the live-coding exercise.

REVIEW TOPICS
System knowledge: relational databases, distributed systems, concurrency with coroutines,
threading, multiprocessing
Common data structures and algorithms: lists, hash tables, stacks, trees, heaps/priority queues

BEST PRACTICES
If you don't understand a question, ask for clarification. We’re here to help!
When you’re asked to provide a solution, first define and frame the problem as you see it.
If you need to assume something, ask the interviewer if your assumption is correct.
When you’re solving a problem, spend some time describing your thought process and proposed
solution, then dive into the implementation.
Think about test cases for your code, including edge or error cases.
After you reach a working solution, consider how you can refactor the code for better
performance or readability.

ASK QUESTIONS
This is a great opportunity to hear what it’s like working on the team. Take full advantage of it!