// 我们有两种瓷砖：一种 2x1 多米诺形状，一种“L”型三格骨牌形状。这些形状可以被旋转。
// XX  <- 多米诺

// XX  <- 三格骨牌
// X

// 给定N，有多少方法可以铺完一个2 x N的地板？返回答案模 10^9 + 7 之后的结果.

// 输入: 3 
// 输出: 5
// 解释: 下列为5种方式, 不同的字母表示不同的瓷砖
//   1. XYZ  2. XXZ  3. XYY  4. XXY  5. XYY
//      XYZ     YYZ     XZZ     XYY     XXY

// 定义状态:

// f[i][j] 表示铺满 2 x i 的地板, 尾端形状为 j 时的方案数, 尾端一共有三种情况:

// f[i][0] 表示尾端没有多余, 就是说一共有 2 x i 块格子
// f[i][1] 表示上面那一行多出来了一块, 就是说上面有 i + 1 个格子, 下面有 i 个格子
// f[i][2] 表示下面一行多出一块, 就是说上面有 i 个格子, 下面有 i + 1 个格子
// 状态转移:

// f[i][0] = f[i - 1][0] + f[i - 2][0] + f[i - 2][1] + f[i - 2][2]  // 竖着放一块I型, 或者横着放两块I型, 或者放L型(两种方向)
// f[i][1] = f[i - 1][0] + f[i - 1][2] // 在上面一行横着放一块I型, 或者放L型
// f[i][2] = f[i - 1][0] + f[i - 1][1] // 在下面一行横着放一块I型, 或者放L型
// 边界: f[0][0] = f[1][0] = f[1][1] = f[1][2] = 1

// 注意: 为了避免运算过程中溢出, C++/Java建议定义f数组为 long (long) 类型

// 优化: f[i] 只涉及 f[i - 1] 和 f[i - 2], 所以可以用滚动数组将空间复杂度降低至 O(1)

public class DominTrominoTiling {
  public int numTilings(int N) {
    if (N < 3) return N;
    
    final long MOD = 1000000007;
    
    long[][] f = new long[N + 1][3];
    f[0][0] = f[1][0] = f[1][1] = f[1][2] = 1;
    
    for (int i = 2; i <= N; i++) {
        f[i][0] = (f[i - 1][0] + f[i - 2][0] + f[i - 2][1] + f[i - 2][2]) % MOD;
        f[i][1] = (f[i - 1][0] + f[i - 1][2]) % MOD;
        f[i][2] = (f[i - 1][0] + f[i - 1][1]) % MOD;
    }
    
    return (int)f[N][0];
}
}