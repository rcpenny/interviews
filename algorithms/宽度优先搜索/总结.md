## 宽搜要点 BFS Key Points
1. 使用队列作为主要的数据结构 Queue
2. 是否需要实现分层？ int size = queue.size()
3. 需要分层的算法比不需要分层的算法多一个循环

## BFS in Graph
1. 图中存在环
2. 存在环意味着，同一个节点可能重复进入队列 Set<E> visited
3. 时间复杂度 O(N + M) 其中 N 为点数，M 为边数

## BFS in Matrix
1. R行C列
2. R*C个点，R*C*2条边（每个点上下左右4条边，每条边被2个点共享）
3. 矩阵中BFS时间复杂度 = O(R * C)
4. 其余一些matrix问题可用并查集 Union Find解决

## 拓扑排序概念
1. 入度（In-degree) A->B
2. 有向图（Directed Graph）中指向当前节点的点的个数（或指向当前节点的边的条数）

### 算法描述：
1. 生成数据结构（如果需要的话）
2. 统计每个点的入度
3. 将每个入度为 0 的点放入队列（Queue）中作为起始节点
4. 不断从队列中拿出一个点，去掉这个点的所有连边（指向其他点的边），其他点的相应的入度 - 1
5. 一旦发现新的入度为 0 的点，丢入队列中
- 拓扑排序并不是传统的排序算法
- 一个图可能存在多个拓扑序（Topological Order），也可能不存在任何拓扑序

## 拓扑排序的四种不同问法
1. 求任意1个拓扑序（Topological Order）
2. 问是否存在拓扑序（是否可以被拓扑排序）
3. 求所有的拓扑序 DFS
4. 求是否存在且仅存在一个拓扑序（Queue中最多同时只有1个节点）

- 考点1：如何构建图
- 考点2：如何存储图
- HashMap<key, value> pre_course -> follow_courses
- 考点3：如何拓扑排序

## 总结 Conclusion
- 能用 BFS 的一定不要用 DFS
- 图的遍历（由点及面，层级遍历）
- 层级遍历: 简单图最短路径
- 是否需要层级遍历 size = queue.size()
- 拓扑排序
- 坐标变换数组 dx, dy, inBound
