##矩阵 Matrix
R行C列/
R*C个点，R*C*2 条边（每个点上下左右4条边，每条边被2个点共享）。/
矩阵中BFS时间复杂度 = O(R * C)/
/
其余一些matrix问题可用并查集 Union Find解决/

##拓扑排序概念
入度（In-degree）：/
有向图（Directed Graph）中指向当前节点的点的个数（或指向当前节点的边的条数）
/
算法描述：/
1. 统计每个点的入度/
2. 将每个入度为 0 的点放入队列（Queue）中作为起始节点/
3. 不断从队列中拿出一个点，去掉这个点的所有连边（指向其他点的边），其他点的相应的入度 - 1/
4. 一旦发现新的入度为 0 的点，丢回队列中/
/
拓扑排序并不是传统的排序算法/
一个图可能存在多个拓扑序（Topological Order），也可能不存在任何拓扑序

##拓扑排序的四种不同问法/
求任意1个拓扑序（Topological Order）/
问是否存在拓扑序（是否可以被拓扑排序）/
求所有的拓扑序 DFS/
求是否存在且仅存在一个拓扑序 Queue中最多同时只有1个节点/

##总结 Conclusion
能用 BFS 的一定不要用 DFS（除非面试官特别要求）/
• BFS 的两个使用条件/
• 图的遍历（由点及面，层级遍历）/
• 简单图最短路径/
• 是否需要层级遍历/
• size = queue.size()/
• 拓扑排序必须掌握！/
• 坐标变换数组/
• deltaX, deltaY/
• inBound/